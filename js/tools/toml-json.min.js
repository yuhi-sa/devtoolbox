"use strict";
(function () {
document.addEventListener("DOMContentLoaded", function () {
var tomlInput = document.getElementById("toml-input");
var jsonInput = document.getElementById("json-input");
var outputEl = document.getElementById("output");
var errorEl = document.getElementById("error-message");
var successEl = document.getElementById("success-message");
var btnTomlToJson = document.getElementById("btn-toml-to-json");
var btnJsonToToml = document.getElementById("btn-json-to-toml");
var btnClearToml = document.getElementById("btn-clear-toml");
var btnClearJson = document.getElementById("btn-clear-json");
var btnCopy = document.getElementById("btn-copy");
var panelTomlToJson = document.getElementById("panel-toml-to-json");
var panelJsonToToml = document.getElementById("panel-json-to-toml");
var tabBtns = document.querySelectorAll(".tab-btn");
function showError(msg) {
errorEl.textContent = msg;
errorEl.hidden = false;
successEl.hidden = true;
}
function showSuccess(msg) {
successEl.textContent = msg;
successEl.hidden = false;
errorEl.hidden = true;
}
function clearMessages() {
errorEl.hidden = true;
successEl.hidden = true;
}
tabBtns.forEach(function (btn) {
btn.addEventListener("click", function () {
tabBtns.forEach(function (b) { b.classList.remove("tab-btn--active"); });
btn.classList.add("tab-btn--active");
var tab = btn.dataset.tab;
if (tab === "toml-to-json") {
panelTomlToJson.hidden = false;
panelJsonToToml.hidden = true;
} else {
panelTomlToJson.hidden = true;
panelJsonToToml.hidden = false;
}
outputEl.value = "";
clearMessages();
});
});
function parseTOML(input) {
var result = {};
var lines = input.split("\n");
var currentTable = result;
var currentPath = [];
var lineNum = 0;
for (var li = 0; li < lines.length; li++) {
lineNum = li + 1;
var line = lines[li];
var stripped = stripComment(line);
stripped = stripped.trim();
if (!stripped) continue;
if (stripped.charAt(0) === "[") {
if (stripped.charAt(1) === "[") {
var end = stripped.indexOf("]]");
if (end === -1) throw new Error(lineNum + "行目: 閉じ ']]' がありません。");
var tableName = stripped.substring(2, end).trim();
var path = parseKeyPath(tableName, lineNum);
currentPath = path;
var target = result;
for (var p = 0; p < path.length - 1; p++) {
if (!(path[p] in target)) {
target[path[p]] = {};
}
var val = target[path[p]];
if (Array.isArray(val)) {
target = val[val.length - 1];
} else {
target = val;
}
}
var lastKey = path[path.length - 1];
if (!(lastKey in target)) {
target[lastKey] = [];
}
if (!Array.isArray(target[lastKey])) {
throw new Error(lineNum + "行目: '" + lastKey + "' は配列ではありません。");
}
var newObj = {};
target[lastKey].push(newObj);
currentTable = newObj;
} else {
var end = stripped.indexOf("]");
if (end === -1) throw new Error(lineNum + "行目: 閉じ ']' がありません。");
var tableName = stripped.substring(1, end).trim();
var path = parseKeyPath(tableName, lineNum);
currentPath = path;
currentTable = result;
for (var p = 0; p < path.length; p++) {
if (!(path[p] in currentTable)) {
currentTable[path[p]] = {};
}
var val = currentTable[path[p]];
if (Array.isArray(val)) {
currentTable = val[val.length - 1];
} else {
currentTable = val;
}
}
}
continue;
}
var kvResult = parseKeyValue(stripped, lineNum);
setNestedKey(currentTable, kvResult.keyPath, kvResult.value, lineNum);
}
return result;
}
function parseKeyPath(str, lineNum) {
var keys = [];
var i = 0;
var len = str.length;
while (i < len) {
skipWhitespace();
if (i >= len) break;
var ch = str.charAt(i);
if (ch === '"') {
keys.push(parseQuotedKey('"'));
} else if (ch === "'") {
keys.push(parseQuotedKey("'"));
} else {
var key = "";
while (i < len && str.charAt(i) !== "." && str.charAt(i) !== " " && str.charAt(i) !== "\t") {
key += str.charAt(i);
i++;
}
if (!key) throw new Error(lineNum + "行目: 空のキーです。");
keys.push(key);
}
skipWhitespace();
if (i < len && str.charAt(i) === ".") {
i++;
}
}
return keys;
function skipWhitespace() {
while (i < len && (str.charAt(i) === " " || str.charAt(i) === "\t")) i++;
}
function parseQuotedKey(quote) {
i++;
var key = "";
while (i < len && str.charAt(i) !== quote) {
if (quote === '"' && str.charAt(i) === "\\") {
i++;
if (i < len) {
key += parseEscape(str.charAt(i));
i++;
}
} else {
key += str.charAt(i);
i++;
}
}
if (i < len) i++;
return key;
}
}
function parseKeyValue(line, lineNum) {
var i = 0;
var len = line.length;
var keyPath = [];
while (i < len) {
skipWhitespace();
var ch = line.charAt(i);
if (ch === '"') {
keyPath.push(readQuotedString('"'));
} else if (ch === "'") {
keyPath.push(readQuotedString("'"));
} else {
var key = "";
while (i < len && line.charAt(i) !== "=" && line.charAt(i) !== "." && line.charAt(i) !== " " && line.charAt(i) !== "\t") {
key += line.charAt(i);
i++;
}
if (!key) throw new Error(lineNum + "行目: 空のキーです。");
keyPath.push(key);
}
skipWhitespace();
if (i < len && line.charAt(i) === ".") {
i++;
continue;
}
break;
}
skipWhitespace();
if (i >= len || line.charAt(i) !== "=") {
throw new Error(lineNum + "行目: '=' が必要です。");
}
i++;
skipWhitespace();
var value = parseValue(line.substring(i), lineNum);
return { keyPath: keyPath, value: value };
function skipWhitespace() {
while (i < len && (line.charAt(i) === " " || line.charAt(i) === "\t")) i++;
}
function readQuotedString(quote) {
i++;
var s = "";
while (i < len && line.charAt(i) !== quote) {
if (quote === '"' && line.charAt(i) === "\\") {
i++;
if (i < len) {
s += parseEscape(line.charAt(i));
i++;
}
} else {
s += line.charAt(i);
i++;
}
}
if (i < len) i++;
return s;
}
}
function parseEscape(ch) {
switch (ch) {
case "n": return "\n";
case "t": return "\t";
case "r": return "\r";
case "\\": return "\\";
case '"': return '"';
case "b": return "\b";
case "f": return "\f";
default: return "\\" + ch;
}
}
function parseValue(str, lineNum) {
str = str.trim();
if (!str) throw new Error(lineNum + "行目: 値がありません。");
var val = str;
var ch = val.charAt(0);
if (ch === '"') {
if (val.substring(0, 3) === '"""') {
var end = val.indexOf('"""', 3);
if (end === -1) throw new Error(lineNum + "行目: 閉じ '\"\"\"' がありません。");
return parseBasicString(val.substring(3, end));
}
return readBasicString(val, lineNum);
}
if (ch === "'") {
if (val.substring(0, 3) === "'''") {
var end = val.indexOf("'''", 3);
if (end === -1) throw new Error(lineNum + "行目: 閉じ \"'''\" がありません。");
return val.substring(3, end);
}
var end = val.indexOf("'", 1);
if (end === -1) throw new Error(lineNum + "行目: 閉じ \"'\" がありません。");
return val.substring(1, end);
}
if (val === "true" || val.substring(0, 4) === "true") {
var rest = val.substring(4).trim();
if (!rest || rest.charAt(0) === "#") return true;
}
if (val === "false" || val.substring(0, 5) === "false") {
var rest = val.substring(5).trim();
if (!rest || rest.charAt(0) === "#") return false;
}
if (ch === "[") {
return parseArray(val, lineNum);
}
if (ch === "{") {
return parseInlineTable(val, lineNum);
}
var numStr = val;
var hashIdx = findUnquotedHash(numStr);
if (hashIdx !== -1) {
numStr = numStr.substring(0, hashIdx).trim();
}
if (numStr === "inf" || numStr === "+inf") return Infinity;
if (numStr === "-inf") return -Infinity;
if (numStr === "nan" || numStr === "+nan" || numStr === "-nan") return NaN;
var cleanNum = numStr.replace(/_/g, "");
if (cleanNum.substring(0, 2) === "0x" || cleanNum.substring(0, 2) === "0X") {
var n = parseInt(cleanNum, 16);
if (!isNaN(n)) return n;
}
if (cleanNum.substring(0, 2) === "0o" || cleanNum.substring(0, 2) === "0O") {
var n = parseInt(cleanNum.substring(2), 8);
if (!isNaN(n)) return n;
}
if (cleanNum.substring(0, 2) === "0b" || cleanNum.substring(0, 2) === "0B") {
var n = parseInt(cleanNum.substring(2), 2);
if (!isNaN(n)) return n;
}
if (/^[+\-]?\d[\d]*(\.\d[\d]*)?(e[+\-]?\d+)?$/i.test(cleanNum)) {
if (cleanNum.indexOf(".") !== -1 || cleanNum.toLowerCase().indexOf("e") !== -1) {
return parseFloat(cleanNum);
}
return parseInt(cleanNum, 10);
}
if (/^[+\-]?\d+$/.test(cleanNum)) {
return parseInt(cleanNum, 10);
}
throw new Error(lineNum + "行目: 不明な値 '" + numStr + "'");
}
function readBasicString(val, lineNum) {
var i = 1;
var s = "";
while (i < val.length && val.charAt(i) !== '"') {
if (val.charAt(i) === "\\") {
i++;
if (i < val.length) {
s += parseEscape(val.charAt(i));
}
} else {
s += val.charAt(i);
}
i++;
}
if (i >= val.length) throw new Error(lineNum + '行目: 閉じ \'"\' がありません。');
return s;
}
function parseBasicString(s) {
var result = "";
var i = 0;
while (i < s.length) {
if (s.charAt(i) === "\\") {
i++;
if (i < s.length) {
result += parseEscape(s.charAt(i));
}
} else {
result += s.charAt(i);
}
i++;
}
return result;
}
function parseArray(val, lineNum) {
var arr = [];
var i = 1;
var len = val.length;
while (i < len) {
skipWS();
if (i >= len) break;
if (val.charAt(i) === "]") break;
if (val.charAt(i) === "#") break;
var elemStr = readElement("]");
if (elemStr.trim()) {
arr.push(parseValue(elemStr.trim(), lineNum));
}
skipWS();
if (i < len && val.charAt(i) === ",") {
i++;
}
}
return arr;
function skipWS() {
while (i < len && (val.charAt(i) === " " || val.charAt(i) === "\t" || val.charAt(i) === "\n" || val.charAt(i) === "\r")) i++;
}
function readElement(terminator) {
var depth = 0;
var inStr = false;
var strChar = "";
var elem = "";
while (i < len) {
var ch = val.charAt(i);
if (inStr) {
elem += ch;
if (ch === "\\" && i + 1 < len) {
i++;
elem += val.charAt(i);
i++;
continue;
}
if (ch === strChar) inStr = false;
i++;
continue;
}
if (ch === '"' || ch === "'") {
inStr = true;
strChar = ch;
elem += ch;
i++;
continue;
}
if (ch === "[" || ch === "{") depth++;
if (ch === "]" || ch === "}") {
if (depth === 0) break;
depth--;
}
if (ch === "," && depth === 0) break;
if (ch === "#" && depth === 0) {
while (i < len && val.charAt(i) !== "\n") i++;
continue;
}
elem += ch;
i++;
}
return elem;
}
}
function parseInlineTable(val, lineNum) {
var obj = {};
var i = 1;
var len = val.length;
while (i < len) {
skipWS();
if (i >= len) break;
if (val.charAt(i) === "}") break;
var keyPart = "";
while (i < len && val.charAt(i) !== "=" && val.charAt(i) !== "}") {
keyPart += val.charAt(i);
i++;
}
var key = keyPart.trim();
if (!key) break;
if ((key.charAt(0) === '"' && key.charAt(key.length - 1) === '"') ||
(key.charAt(0) === "'" && key.charAt(key.length - 1) === "'")) {
key = key.substring(1, key.length - 1);
}
skipWS();
if (i < len && val.charAt(i) === "=") i++;
skipWS();
var elemStr = readInlineElement();
obj[key] = parseValue(elemStr.trim(), lineNum);
skipWS();
if (i < len && val.charAt(i) === ",") i++;
}
return obj;
function skipWS() {
while (i < len && (val.charAt(i) === " " || val.charAt(i) === "\t")) i++;
}
function readInlineElement() {
var depth = 0;
var inStr = false;
var strChar = "";
var elem = "";
while (i < len) {
var ch = val.charAt(i);
if (inStr) {
elem += ch;
if (ch === "\\" && i + 1 < len) {
i++;
elem += val.charAt(i);
i++;
continue;
}
if (ch === strChar) inStr = false;
i++;
continue;
}
if (ch === '"' || ch === "'") {
inStr = true;
strChar = ch;
elem += ch;
i++;
continue;
}
if (ch === "[" || ch === "{") depth++;
if (ch === "]" || ch === "}") {
if (depth === 0) break;
depth--;
}
if (ch === "," && depth === 0) break;
elem += ch;
i++;
}
return elem;
}
}
function stripComment(line) {
var inStr = false;
var strChar = "";
for (var i = 0; i < line.length; i++) {
var ch = line.charAt(i);
if (inStr) {
if (ch === "\\" && strChar === '"' && i + 1 < line.length) {
i++;
continue;
}
if (ch === strChar) inStr = false;
continue;
}
if (ch === '"' || ch === "'") {
inStr = true;
strChar = ch;
continue;
}
if (ch === "#") {
return line.substring(0, i);
}
}
return line;
}
function findUnquotedHash(str) {
var inStr = false;
var strChar = "";
for (var i = 0; i < str.length; i++) {
var ch = str.charAt(i);
if (inStr) {
if (ch === "\\" && strChar === '"') { i++; continue; }
if (ch === strChar) inStr = false;
continue;
}
if (ch === '"' || ch === "'") { inStr = true; strChar = ch; continue; }
if (ch === "#") return i;
}
return -1;
}
function setNestedKey(obj, keyPath, value, lineNum) {
var current = obj;
for (var i = 0; i < keyPath.length - 1; i++) {
var k = keyPath[i];
if (!(k in current)) {
current[k] = {};
}
if (typeof current[k] !== "object" || current[k] === null || Array.isArray(current[k])) {
throw new Error(lineNum + "行目: キー '" + k + "' は既にオブジェクト以外の値です。");
}
current = current[k];
}
var lastKey = keyPath[keyPath.length - 1];
current[lastKey] = value;
}
function jsonToToml(data, prefix) {
if (typeof data !== "object" || data === null || Array.isArray(data)) {
throw new Error("トップレベルはオブジェクトである必要があります。");
}
prefix = prefix || "";
var lines = [];
var tableSections = [];
var keys = Object.keys(data);
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var val = data[key];
var fullKey = prefix ? prefix + "." + formatKey(key) : formatKey(key);
if (val === null || val === undefined) {
continue;
} else if (Array.isArray(val)) {
if (val.length > 0 && isArrayOfTables(val)) {
for (var j = 0; j < val.length; j++) {
tableSections.push("");
tableSections.push("[[" + fullKey + "]]");
var inner = jsonToToml(val[j], "");
if (inner) tableSections.push(inner);
}
} else {
lines.push(formatKey(key) + " = " + formatValue(val));
}
} else if (typeof val === "object") {
if (hasNestedObjects(val)) {
tableSections.push("");
tableSections.push("[" + fullKey + "]");
var inner = jsonToToml(val, fullKey);
if (inner) tableSections.push(inner);
} else {
if (Object.keys(val).length <= 3 && !hasNestedObjects(val)) {
lines.push(formatKey(key) + " = " + formatInlineTable(val));
} else {
tableSections.push("");
tableSections.push("[" + fullKey + "]");
var inner = jsonToToml(val, fullKey);
if (inner) tableSections.push(inner);
}
}
} else {
lines.push(formatKey(key) + " = " + formatValue(val));
}
}
var result = lines.join("\n");
if (tableSections.length > 0) {
result += "\n" + tableSections.join("\n");
}
return result.trim();
}
function isArrayOfTables(arr) {
for (var i = 0; i < arr.length; i++) {
if (typeof arr[i] !== "object" || arr[i] === null || Array.isArray(arr[i])) {
return false;
}
}
return true;
}
function hasNestedObjects(obj) {
var keys = Object.keys(obj);
for (var i = 0; i < keys.length; i++) {
var v = obj[keys[i]];
if (typeof v === "object" && v !== null && !Array.isArray(v)) return true;
if (Array.isArray(v) && v.length > 0 && isArrayOfTables(v)) return true;
}
return false;
}
function formatKey(key) {
if (/^[a-zA-Z0-9_-]+$/.test(key)) {
return key;
}
return '"' + escapeString(key) + '"';
}
function formatValue(val) {
if (val === null || val === undefined) return '""';
if (typeof val === "boolean") return val ? "true" : "false";
if (typeof val === "number") {
if (val !== val) return "nan";
if (val === Infinity) return "inf";
if (val === -Infinity) return "-inf";
if (Number.isInteger(val)) return String(val);
return String(val);
}
if (typeof val === "string") {
return '"' + escapeString(val) + '"';
}
if (Array.isArray(val)) {
var items = [];
for (var i = 0; i < val.length; i++) {
items.push(formatValue(val[i]));
}
return "[" + items.join(", ") + "]";
}
if (typeof val === "object") {
return formatInlineTable(val);
}
return String(val);
}
function formatInlineTable(obj) {
var parts = [];
var keys = Object.keys(obj);
for (var i = 0; i < keys.length; i++) {
parts.push(formatKey(keys[i]) + " = " + formatValue(obj[keys[i]]));
}
return "{ " + parts.join(", ") + " }";
}
function escapeString(str) {
return str
.replace(/\\/g, "\\\\")
.replace(/"/g, '\\"')
.replace(/\n/g, "\\n")
.replace(/\r/g, "\\r")
.replace(/\t/g, "\\t")
.replace(/\b/g, "\\b")
.replace(/\f/g, "\\f");
}
btnTomlToJson.addEventListener("click", function () {
clearMessages();
var input = tomlInput.value.trim();
if (!input) {
showError("TOMLを入力してください。");
return;
}
try {
var result = parseTOML(input);
outputEl.value = JSON.stringify(result, null, 2);
showSuccess("TOML → JSON 変換が完了しました。");
} catch (e) {
showError("TOMLパースエラー: " + e.message);
outputEl.value = "";
}
});
btnJsonToToml.addEventListener("click", function () {
clearMessages();
var input = jsonInput.value.trim();
if (!input) {
showError("JSONを入力してください。");
return;
}
try {
var data = JSON.parse(input);
var toml = jsonToToml(data, "");
outputEl.value = toml;
showSuccess("JSON → TOML 変換が完了しました。");
} catch (e) {
showError("変換エラー: " + e.message);
outputEl.value = "";
}
});
btnClearToml.addEventListener("click", function () {
tomlInput.value = "";
outputEl.value = "";
clearMessages();
});
btnClearJson.addEventListener("click", function () {
jsonInput.value = "";
outputEl.value = "";
clearMessages();
});
btnCopy.addEventListener("click", function () {
var text = outputEl.value;
if (!text) return;
navigator.clipboard.writeText(text).then(function () {
showSuccess("コピーしました。");
});
});
});
})();